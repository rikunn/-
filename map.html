<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Live Stream Map Overlay</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        /* 基本設定: 背景透過 */
        body, html {
            margin: 0;
            padding: 0;
            width: 1920px; /* Full HD width assumption */
            height: 1080px; /* Full HD height assumption */
            background-color: transparent; /* 重要: 透過 */
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* 右上のコンテナ */
        #overlay-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 450px; /* マップの表示幅 */
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        /* マップのマスク（円形や角丸にするための枠） */
        #map-wrapper {
            width: 400px;
            height: 400px;
            position: relative;
            overflow: hidden;
            border-radius: 20px; /* 角丸 */
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            background: rgba(0, 0, 0, 0.2); /* マップロード前の背景 */
            border: 2px solid rgba(255, 255, 255, 0.8);
        }

        /* Leafletマップ本体 */
        #map {
            width: 600px; /* 回転しても端が見えないように表示領域より大きくする */
            height: 600px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* 中心配置 */
            background: transparent;
        }

        /* Leafletのコントロール（ズームボタン等）を隠す */
        .leaflet-control-container {
            display: none;
        }

        /* マップ下の情報表示エリア */
        #stats-container {
            margin-top: 10px;
            text-align: right;
            color: white;
            text-shadow: 
                2px 2px 0 #000, 
                -1px -1px 0 #000,  
                1px -1px 0 #000,
                -1px 1px 0 #000,
                1px 1px 0 #000;
            font-weight: bold;
        }

        .stat-line {
            font-size: 28px;
            line-height: 1.2;
            font-family: monospace; /* 等幅フォントで数字のブレを防ぐ */
        }

        .stat-sub {
            font-size: 22px;
            color: #ddd;
        }

        /* ピンアイコンのスタイル補正 */
        .custom-pin-icon {
            background: transparent;
        }
    </style>
</head>
<body>

    <div id="overlay-container">
        <!-- マップエリア -->
        <div id="map-wrapper">
            <div id="map"></div>
        </div>
        
        <!-- 情報エリア -->
        <div id="stats-container">
            <div class="stat-line" id="speed-dist">0km/h (計 0.0km)</div>
            <div class="stat-line stat-sub" id="coords">00.0000 / 000.0000</div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        // --- 設定 ---
        const ZOOM_LEVEL = 16; // ズームレベル
        const GEOJSON_PATH = 'assets/JapanMap.geojson';
        
        // --- 変数初期化 ---
        let map;
        let currentMarker;
        let pathPolyline;
        let pathCoords = []; // 座標履歴 [lat, lng]
        let totalDistance = 0; // メートル
        let lastLatLng = null;
        let currentHeading = 0;

        // --- SVGピンの定義 ---
        const svgPin = `
        <svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <linearGradient id="pinGradient1" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" style="stop-color:#00c6ff;" />
              <stop offset="100%" style="stop-color:#0072ff;" />
            </linearGradient>
            <filter id="dropShadow1" x="-20%" y="-20%" width="140%" height="140%">
              <feGaussianBlur in="SourceAlpha" stdDeviation="3"/>
              <feOffset dx="1" dy="2"/>
              <feMerge>
                <feMergeNode/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
          </defs>
          <g filter="url(#dropShadow1)">
            <path d="M50 10 L75 70 L50 60 L25 70 Z" 
                  fill="url(#pinGradient1)" 
                  stroke="#ffffff" 
                  stroke-width="1.5" 
                  stroke-linejoin="round"/>
          </g>
        </svg>`;

        const pinIcon = L.divIcon({
            className: 'custom-pin-icon',
            html: svgPin,
            iconSize: [80, 80], // 表示サイズ
            iconAnchor: [40, 40] // アイコンの中心 (SVGの中心に合わせる)
        });

        // --- マップ初期化 ---
        function initMap() {
            // 背景透過のため zoomControlなどを無効化
            map = L.map('map', {
                zoomControl: false,
                attributionControl: false,
                zoomAnimation: false, // 回転時のちらつき防止
                fadeAnimation: false,
                markerZoomAnimation: false,
                background: 'transparent' // Leafletの背景指定
            }).setView([35.6895, 139.6917], ZOOM_LEVEL); // 初期値：東京

            // OpenStreetMapレイヤー
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                opacity: 0.9, // 少し透過させて背景になじませる
                maxZoom: 19
            }).addTo(map);

            // 軌跡用ポリライン（赤線）
            pathPolyline = L.polyline([], {
                color: 'red',
                weight: 5,
                opacity: 0.8,
                lineJoin: 'round'
            }).addTo(map);

            // GeoJSON読み込み (県境)
            fetch(GEOJSON_PATH)
                .then(response => {
                    if (!response.ok) throw new Error("GeoJSON not found");
                    return response.json();
                })
                .then(data => {
                    L.geoJSON(data, {
                        style: {
                            color: "#00ff00", // 境界線の色 (緑など目立つ色)
                            weight: 2,
                            opacity: 0.6,
                            fillOpacity: 0 // 塗りつぶしなし
                        }
                    }).addTo(map);
                })
                .catch(err => console.log('GeoJSON load error (or running locally without server):', err));
        }

        // --- 位置情報追跡 ---
        function startTracking() {
            if (!navigator.geolocation) {
                alert("Geolocation is not supported by your browser");
                return;
            }

            navigator.geolocation.watchPosition(updatePosition, handleError, {
                enableHighAccuracy: true,
                maximumAge: 0,
                timeout: 5000
            });
        }

        function updatePosition(position) {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            const speedMs = position.coords.speed || 0; // m/s
            const speedKmh = (speedMs * 3.6).toFixed(0); // km/h変換

            const currentLatLng = L.latLng(lat, lng);

            // マーカー更新
            if (!currentMarker) {
                currentMarker = L.marker(currentLatLng, {icon: pinIcon}).addTo(map);
            } else {
                currentMarker.setLatLng(currentLatLng);
            }

            // マップ中心移動
            map.panTo(currentLatLng, {animate: false});

            // 距離計算と軌跡
            if (lastLatLng) {
                const dist = lastLatLng.distanceTo(currentLatLng);
                if (dist > 2) { // ノイズ対策: 2m以上動いたら記録
                    totalDistance += dist;
                    pathCoords.push(currentLatLng);
                    pathPolyline.setLatLngs(pathCoords);
                    lastLatLng = currentLatLng;
                }
            } else {
                lastLatLng = currentLatLng;
                pathCoords.push(currentLatLng);
            }

            // 画面表示更新
            const distKm = (totalDistance / 1000).toFixed(1);
            document.getElementById('speed-dist').innerText = `${speedKmh}km/h (計 ${distKm}km)`;
            document.getElementById('coords').innerText = `${lat.toFixed(5)} / ${lng.toFixed(5)}`;
        }

        function handleError(error) {
            console.warn('Geolocation Error:', error);
        }

        // --- コンパス (Heading Up) ---
        // デバイスの向きに合わせてマップを回転させる
        function startCompass() {
            if (window.DeviceOrientationEvent) {
                // iOS 13+ permission request (if needed, usually triggered by user action)
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    // 自動では呼べないため、本来は「開始ボタン」が必要ですが、
                    // ここではイベントリスナー追加のみ記述します。
                    // 実際のアプリではユーザー操作のクリックイベント内で requestPermission を呼んでください。
                }

                window.addEventListener('deviceorientation', (event) => {
                    let heading = 0;

                    // iOS (webkitCompassHeading) vs Android (alpha)
                    if (event.webkitCompassHeading) {
                        heading = event.webkitCompassHeading;
                    } else if (event.alpha) {
                        // Androidのalphaは北=0ではない場合があるが、簡易的に使用
                        // w3c標準では alpha=0 は北。ただしデバイスの持ち方による。
                        // ここでは一般的な補正を使用
                        heading = 360 - event.alpha; 
                    }

                    currentHeading = heading;
                    rotateMap(heading);
                }, true);
            }
        }

        function rotateMap(heading) {
            const mapDiv = document.getElementById('map');
            // マップ全体を回転（ヘディングアップ）
            // マップが北を基準に描画されているため、heading分だけマイナス回転させると
            // 進行方向が上に来る。
            mapDiv.style.transform = `translate(-50%, -50%) rotate(${-heading}deg)`;

            // ピン（アイコン）は常に画面の上（進行方向）を向かせたい。
            // SVGのピン自体が上を向くデザインなので、
            // マップコンテナと一緒に回転してしまうピンを、逆回転させて
            // 常に画面に対して垂直を保つ。
            if (currentMarker) {
                const iconElement = currentMarker.getElement();
                if (iconElement) {
                    // アイコン自体を逆回転させて、常に画面上方向を向くようにする
                    // mapDivが回転しているので、その子要素であるiconも回転している。
                    // iconに rotate(heading) を与えれば相殺される。
                    iconElement.style.transform += ` rotate(${heading}deg)`;
                    
                    // Leafletはtransformを座標指定に使っているため、既存のtransformを維持しつつ回転を追加する必要があるが、
                    // L.divIconのCSS更新は重くなる可能性がある。
                    // 簡易的な方法：CSSで .leaflet-marker-icon に対して counter-rotation を適用するアプローチが一般的
                    // 今回はSVG自体が「上向き」なので、マップが回転して「上が北」でなくなっても、
                    // ピンは「画面の上（進行方向）」を向いていてほしい。
                    // マップを回す = 世界を回す。
                    // 車（ピン）は画面に対して固定。
                    // したがって、マップdivを回すだけで、ピンはマップと一緒に回ってしまう。
                    // ピンを「画面に対して上固定」にするには、マップの回転分を打ち消す回転が必要。
                    
                    // 実装ハック: Leafletのマーカーはマップペイン内にある。
                    // マップ全体をCSS回転させるとマーカーも回る。
                    // マーカーのDOMを取得して、逆回転させる。
                    const currentTransform = iconElement.style.transform.split(' rotate')[0]; // 既存のtranslateのみ取得
                    iconElement.style.transform = `${currentTransform} rotate(${heading}deg)`;
                }
            }
        }

        // --- 実行 ---
        window.onload = () => {
            initMap();
            startTracking();
            startCompass();
        };

    </script>
</body>
</html>
