<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Live Stream Map Overlay (WebSocket)</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        /* 基本設定: 背景透過 */
        body, html {
            margin: 0;
            padding: 0;
            width: 1920px; /* Full HD width assumption */
            height: 1080px; /* Full HD height assumption */
            background-color: transparent; /* 重要: 透過 */
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* 右上のコンテナ */
        #overlay-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 450px; /* マップの表示幅 */
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        /* マップのマスク（円形や角丸にするための枠） */
        #map-wrapper {
            width: 400px;
            height: 400px;
            position: relative;
            overflow: hidden;
            border-radius: 20px; /* 角丸 */
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            background: rgba(0, 0, 0, 0.2); /* マップロード前の背景 */
            border: 2px solid rgba(255, 255, 255, 0.8);
        }

        /* Leafletマップ本体 */
        #map {
            width: 600px; /* 回転しても端が見えないように表示領域より大きくする */
            height: 600px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* 中心配置 */
            background: transparent;
        }

        /* Leafletのコントロール（ズームボタン等）を隠す */
        .leaflet-control-container {
            display: none;
        }

        /* マップ下の情報表示エリア */
        #stats-container {
            margin-top: 10px;
            text-align: right;
            color: white;
            text-shadow: 
                2px 2px 0 #000, 
                -1px -1px 0 #000,  
                1px -1px 0 #000,
                -1px 1px 0 #000,
                1px 1px 0 #000;
            font-weight: bold;
        }

        .stat-line {
            font-size: 28px;
            line-height: 1.2;
            font-family: monospace; /* 等幅フォントで数字のブレを防ぐ */
        }

        .stat-sub {
            font-size: 22px;
            color: #ddd;
        }

        /* ピンアイコンのスタイル補正 */
        .custom-pin-icon {
            background: transparent;
        }
        
        /* 接続状態表示（デバッグ用・必要なければdisplay:noneに） */
        #status-indicator {
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }
    </style>
</head>
<body>

    <div id="overlay-container">
        <!-- マップエリア -->
        <div id="map-wrapper">
            <div id="map"></div>
        </div>
        
        <!-- 情報エリア -->
        <div id="stats-container">
            <div class="stat-line" id="speed-dist">0km/h (計 0.0km)</div>
            <div class="stat-line stat-sub" id="coords">Waiting for WS...</div>
            <div id="status-indicator">Connecting...</div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        // --- 設定 ---
        const ZOOM_LEVEL = 16;
        const GEOJSON_PATH = 'assets/JapanMap.geojson';
        const WS_URL = 'ws://localhost:8887';
        const RECONNECT_INTERVAL = 10000; // 10秒
        
        // --- 変数初期化 ---
        let map;
        let currentMarker;
        let pathPolyline;
        let pathCoords = []; // 座標履歴 [lat, lng]
        let totalDistance = 0; // メートル
        let lastLatLng = null;
        let ws = null;

        // --- SVGピンの定義 ---
        const svgPin = `
        <svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <linearGradient id="pinGradient1" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" style="stop-color:#00c6ff;" />
              <stop offset="100%" style="stop-color:#0072ff;" />
            </linearGradient>
            <filter id="dropShadow1" x="-20%" y="-20%" width="140%" height="140%">
              <feGaussianBlur in="SourceAlpha" stdDeviation="3"/>
              <feOffset dx="1" dy="2"/>
              <feMerge>
                <feMergeNode/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
          </defs>
          <g filter="url(#dropShadow1)">
            <path d="M50 10 L75 70 L50 60 L25 70 Z" 
                  fill="url(#pinGradient1)" 
                  stroke="#ffffff" 
                  stroke-width="1.5" 
                  stroke-linejoin="round"/>
          </g>
        </svg>`;

        const pinIcon = L.divIcon({
            className: 'custom-pin-icon',
            html: svgPin,
            iconSize: [80, 80],
            iconAnchor: [40, 40]
        });

        // --- マップ初期化 ---
        function initMap() {
            map = L.map('map', {
                zoomControl: false,
                attributionControl: false,
                zoomAnimation: false,
                fadeAnimation: false,
                markerZoomAnimation: false,
                background: 'transparent'
            }).setView([35.6895, 139.6917], ZOOM_LEVEL); // 初期値：東京

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                opacity: 0.9,
                maxZoom: 19
            }).addTo(map);

            pathPolyline = L.polyline([], {
                color: 'red',
                weight: 5,
                opacity: 0.8,
                lineJoin: 'round'
            }).addTo(map);

            fetch(GEOJSON_PATH)
                .then(response => {
                    if (!response.ok) throw new Error("GeoJSON not found");
                    return response.json();
                })
                .then(data => {
                    L.geoJSON(data, {
                        style: {
                            color: "#00ff00",
                            weight: 2,
                            opacity: 0.6,
                            fillOpacity: 0
                        }
                    }).addTo(map);
                })
                .catch(err => console.log('GeoJSON info:', err));
        }

        // --- WebSocket接続 & 位置情報更新 ---
        function connectWebSocket() {
            updateStatus("Connecting to " + WS_URL + " ...");
            
            try {
                ws = new WebSocket(WS_URL);
            } catch (e) {
                console.error("WS Init Error:", e);
                scheduleReconnect();
                return;
            }

            ws.onopen = () => {
                console.log('WebSocket Connected');
                updateStatus("Connected");
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    // 期待フォーマット: { "lat": 0, "lon": 0, "speed": 0 }
                    if (data.lat !== undefined && data.lon !== undefined) {
                        updatePosition(data.lat, data.lon, data.speed);
                    }
                } catch (e) {
                    console.error('JSON Parse Error', e);
                }
            };

            ws.onclose = (e) => {
                console.log('WebSocket Closed', e);
                updateStatus("Disconnected. Retrying in 10s...");
                scheduleReconnect();
            };

            ws.onerror = (err) => {
                console.error('WebSocket Error', err);
                ws.close(); // Closeを呼んでoncloseへ移行
            };
        }

        function scheduleReconnect() {
            setTimeout(() => {
                connectWebSocket();
            }, RECONNECT_INTERVAL);
        }

        function updatePosition(lat, lng, speedRaw) {
            // speedRawの単位が m/s か km/h か不明ですが、
            // 一般的なGPS生データ(m/s)と仮定して km/h に変換します。
            // もし元データがすでに km/h なら "* 3.6" を削除してください。
            const speedMs = parseFloat(speedRaw) || 0;
            const speedKmh = (speedMs * 3.6).toFixed(0); 
            
            const currentLatLng = L.latLng(lat, lng);

            // マーカー更新
            if (!currentMarker) {
                currentMarker = L.marker(currentLatLng, {icon: pinIcon}).addTo(map);
            } else {
                currentMarker.setLatLng(currentLatLng);
            }

            // マップ中心移動
            map.panTo(currentLatLng, {animate: false});

            // 距離計算と軌跡
            if (lastLatLng) {
                const dist = lastLatLng.distanceTo(currentLatLng);
                // ノイズ対策: わずかな移動は無視 (例: 1m未満)
                if (dist > 1) { 
                    totalDistance += dist;
                    pathCoords.push(currentLatLng);
                    pathPolyline.setLatLngs(pathCoords);
                    lastLatLng = currentLatLng;
                }
            } else {
                lastLatLng = currentLatLng;
                pathCoords.push(currentLatLng);
            }

            // 表示更新
            const distKm = (totalDistance / 1000).toFixed(1);
            document.getElementById('speed-dist').innerText = `${speedKmh}km/h (計 ${distKm}km)`;
            document.getElementById('coords').innerText = `${lat.toFixed(5)} / ${lng.toFixed(5)}`;
        }

        function updateStatus(msg) {
            const el = document.getElementById('status-indicator');
            if(el) el.innerText = msg;
        }

        // --- コンパス (Heading Up) ---
        // WebSocketに方位が含まれていないため、引き続き端末センサーを使用します。
        // WebViewによっては動作しない可能性があります。
        function startCompass() {
            if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', (event) => {
                    let heading = 0;
                    if (event.webkitCompassHeading) {
                        heading = event.webkitCompassHeading;
                    } else if (event.alpha) {
                        heading = 360 - event.alpha; 
                    }
                    rotateMap(heading);
                }, true);
            }
        }

        function rotateMap(heading) {
            const mapDiv = document.getElementById('map');
            mapDiv.style.transform = `translate(-50%, -50%) rotate(${-heading}deg)`;

            if (currentMarker) {
                const iconElement = currentMarker.getElement();
                if (iconElement) {
                    const currentTransform = iconElement.style.transform.split(' rotate')[0];
                    iconElement.style.transform = `${currentTransform} rotate(${heading}deg)`;
                }
            }
        }

        // --- 実行 ---
        window.onload = () => {
            initMap();
            connectWebSocket(); // Geolocationの代わりにWS接続を開始
            startCompass();
        };

    </script>
</body>
</html>
