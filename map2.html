<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Live Stream Map Overlay (Fixed Rotation)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 1920px;
            height: 1080px;
            background-color: transparent;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #overlay-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 450px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        #map-wrapper {
            width: 400px;
            height: 400px;
            position: relative;
            overflow: hidden;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            background: rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.8);
        }

        #map {
            width: 600px;
            height: 600px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: transparent;
        }

        .leaflet-control-container {
            display: none;
        }

        #stats-container {
            margin-top: 10px;
            text-align: right;
            color: white;
            text-shadow:
                2px 2px 0 #000,
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000,
                1px 1px 0 #000;
            font-weight: bold;
        }

        .stat-line {
            font-size: 28px;
            line-height: 1.2;
            font-family: monospace;
        }

        .stat-sub {
            font-size: 22px;
            color: #ddd;
        }

        .custom-pin-icon {
            background: transparent;
        }

        #status-indicator {
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }

        #status-indicator2 {
            font-size: 13px;
            color: #aaa;
            margin-top: 5px;
        }
    </style>
</head>

<body>

    <div id="overlay-container">
        <div id="map-wrapper">
            <div id="map"></div>
        </div>
        <div id="stats-container">
            <div class="stat-line" id="speed-dist">0km/h (計 0.0km)</div>
            <div class="stat-line stat-sub" id="coords">Waiting for WS...</div>
            <div id="status-indicator2" style="opacity: 1;">0000/00/00 00:00:00.000</div>
            <div id="status-indicator" style="opacity: 0;">Connecting...</div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        const ZOOM_LEVEL = 16;
        const GEOJSON_PATH = 'assets/JapanMap.geojson';
        const WS_URL = 'ws://localhost:8888';
        const RECONNECT_INTERVAL = 10000;
        const HEADING_OFFSET = 0;

        let map;
        let currentMarker;
        let pathPolyline;
        let pathCoords = [];
        let totalDistance = 0;
        let lastLatLng = null;
        let ws = null;

        const svgPin = `
        <svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <linearGradient id="pinGradient1" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" style="stop-color:#00c6ff;" />
              <stop offset="100%" style="stop-color:#0072ff;" />
            </linearGradient>
            <filter id="dropShadow1" x="-20%" y="-20%" width="140%" height="140%">
              <feGaussianBlur in="SourceAlpha" stdDeviation="3"/>
              <feOffset dx="1" dy="2"/>
              <feMerge>
                <feMergeNode/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
          </defs>
          <g filter="url(#dropShadow1)">
            <path d="M50 10 L75 70 L50 60 L25 70 Z" 
                  fill="url(#pinGradient1)" 
                  stroke="#ffffff" 
                  stroke-width="1.5" 
                  stroke-linejoin="round"/>
          </g>
        </svg>`;

        const pinIcon = L.divIcon({
            className: 'custom-pin-icon',
            html: svgPin,
            iconSize: [80, 80],
            iconAnchor: [40, 40]
        });

        function initMap() {
            map = L.map('map', {
                zoomControl: false,
                attributionControl: false,
                zoomAnimation: false,
                fadeAnimation: false,
                markerZoomAnimation: false,
                background: 'transparent'
            }).setView([35.6895, 139.6917], ZOOM_LEVEL);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                opacity: 1,
                maxZoom: 19
            }).addTo(map);

            pathPolyline = L.polyline([], {
                color: 'red',
                weight: 5,
                opacity: 0.8,
                lineJoin: 'round'
            }).addTo(map);

            fetch(GEOJSON_PATH)
                .then(res => { if (!res.ok) throw new Error(); return res.json(); })
                .then(data => {
                    L.geoJSON(data, {
                        style: { color: "#00ff00", weight: 2, opacity: 0.6, fillOpacity: 0 }
                    }).addTo(map);
                })
                .catch(err => console.log('GeoJSON not found/loaded'));
        }

        function connectWebSocket() {
            updateStatus("Connecting to " + WS_URL + " ...");
            try {
                ws = new WebSocket(WS_URL);
            } catch (e) {
                scheduleReconnect();
                return;
            }

            ws.onopen = () => {
                console.log('WS Connected');
                updateStatus("Connected");
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.lat !== undefined && data.lon !== undefined) {
                        updatePosition(data.lat, data.lon, data.speed);
                    }
                } catch (e) {
                    console.error('JSON Parse Error', e);
                }
            };

            ws.onclose = () => {
                updateStatus("Disconnected. Retrying in 10s...");
                scheduleReconnect();
            };

            ws.onerror = () => {
                ws.close();
            };
        }

        function scheduleReconnect() {
            setTimeout(connectWebSocket, RECONNECT_INTERVAL);
        }

        function updatePosition(lat, lng, speedRaw) {
            const speedMs = parseFloat(speedRaw) || 0;
            const speedKmh = (speedMs * 3.6).toFixed(0);
            const currentLatLng = L.latLng(lat, lng);

            if (!currentMarker) {
                currentMarker = L.marker(currentLatLng, { icon: pinIcon }).addTo(map);
            } else {
                currentMarker.setLatLng(currentLatLng);
            }

            map.panTo(currentLatLng, { animate: false });

            if (lastLatLng) {
                const dist = lastLatLng.distanceTo(currentLatLng);
                if (dist > 1) {
                    totalDistance += dist;
                    pathCoords.push(currentLatLng);
                    pathPolyline.setLatLngs(pathCoords);
                    lastLatLng = currentLatLng;
                }
            } else {
                lastLatLng = currentLatLng;
                pathCoords.push(currentLatLng);
            }

            const distKm = (totalDistance / 1000).toFixed(1);
            document.getElementById('speed-dist').innerText = `${speedKmh}km/h (計 ${distKm}km)`;
            document.getElementById('coords').innerText = `${lat.toFixed(5)} / ${lng.toFixed(5)}`;
        }

        function updateStatus(msg) {
            const el = document.getElementById('status-indicator');
            if (el) el.innerText = msg;
        }

        function startCompass() {
            if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', (event) => {
                    let heading = 0;
                    if (event.webkitCompassHeading) {
                        heading = event.webkitCompassHeading;
                    } else if (event.alpha) {
                        heading = 360 - event.alpha;
                    }
                    let screenAngle = 0;
                    if (window.screen && window.screen.orientation) {
                        screenAngle = window.screen.orientation.angle;
                    } else if (typeof window.orientation !== 'undefined') {
                        screenAngle = window.orientation;
                    }
                    let finalHeading = heading + screenAngle + HEADING_OFFSET;

                    rotateMap(finalHeading);
                }, true);
            }
        }

        function rotateMap(heading) {
            const mapDiv = document.getElementById('map');
            mapDiv.style.transform = `translate(-50%, -50%) rotate(${-heading}deg)`;
            if (currentMarker) {
                const iconElement = currentMarker.getElement();
                if (iconElement) {
                    const currentTransform = iconElement.style.transform.split(' rotate')[0];
                    iconElement.style.transform = `${currentTransform} rotate(${heading}deg)`;
                }
            }
        }

        window.onload = () => {
            initMap();
            connectWebSocket();
            startCompass();

            function updateDateTime() {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                const milliseconds = String(now.getMilliseconds()).padStart(3, '0');
                const formattedDateTime =
                    `${year}/${month}/${day} ${hours}:${minutes}:${seconds}`;
                const element = document.getElementById("status-indicator2");
                if (element) {
                    element.textContent = formattedDateTime;
                }
            }
            setInterval(updateDateTime, 1000);
            updateDateTime();
        };

    </script>
</body>

</html>
