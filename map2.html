<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Live Stream Map Overlay (Fixed Rotation)</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        /* 基本設定: 背景透過 */
        body, html {
            margin: 0;
            padding: 0;
            width: 1920px;
            height: 1080px;
            background-color: transparent;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #overlay-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 450px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        #map-wrapper {
            width: 400px;
            height: 400px;
            position: relative;
            overflow: hidden;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            background: rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.8);
        }

        #map {
            width: 600px;
            height: 600px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: transparent;
        }

        .leaflet-control-container {
            display: none;
        }

        #stats-container {
            margin-top: 10px;
            text-align: right;
            color: white;
            text-shadow: 
                2px 2px 0 #000, 
                -1px -1px 0 #000,  
                1px -1px 0 #000,
                -1px 1px 0 #000,
                1px 1px 0 #000;
            font-weight: bold;
        }

        .stat-line {
            font-size: 28px;
            line-height: 1.2;
            font-family: monospace;
        }

        .stat-sub {
            font-size: 22px;
            color: #ddd;
        }

        .custom-pin-icon {
            background: transparent;
        }
        
        #status-indicator {
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }
    </style>
</head>
<body>

    <div id="overlay-container">
        <div id="map-wrapper">
            <div id="map"></div>
        </div>
        <div id="stats-container">
            <div class="stat-line" id="speed-dist">0km/h (計 0.0km)</div>
            <div class="stat-line stat-sub" id="coords">Waiting for WS...</div>
            <div id="status-indicator">Connecting...</div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        // --- 設定 ---
        const ZOOM_LEVEL = 16;
        const GEOJSON_PATH = 'assets/JapanMap.geojson';
        const WS_URL = 'ws://localhost:8888';
        const RECONNECT_INTERVAL = 10000;
        
        // 【重要】向きの補正設定
        // 北を向いた時にまだずれている場合はここを 90, 180, 270, -90 などに変更してください
        // 自動補正を入れていますが、機種によっては手動調整が必要です。
        const HEADING_OFFSET = 0; 
        
        // --- 変数 ---
        let map;
        let currentMarker;
        let pathPolyline;
        let pathCoords = [];
        let totalDistance = 0;
        let lastLatLng = null;
        let ws = null;

        // --- SVGピン ---
        const svgPin = `
        <svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <linearGradient id="pinGradient1" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" style="stop-color:#00c6ff;" />
              <stop offset="100%" style="stop-color:#0072ff;" />
            </linearGradient>
            <filter id="dropShadow1" x="-20%" y="-20%" width="140%" height="140%">
              <feGaussianBlur in="SourceAlpha" stdDeviation="3"/>
              <feOffset dx="1" dy="2"/>
              <feMerge>
                <feMergeNode/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
          </defs>
          <g filter="url(#dropShadow1)">
            <path d="M50 10 L75 70 L50 60 L25 70 Z" 
                  fill="url(#pinGradient1)" 
                  stroke="#ffffff" 
                  stroke-width="1.5" 
                  stroke-linejoin="round"/>
          </g>
        </svg>`;

        const pinIcon = L.divIcon({
            className: 'custom-pin-icon',
            html: svgPin,
            iconSize: [80, 80],
            iconAnchor: [40, 40]
        });

        // --- 初期化 ---
        function initMap() {
            map = L.map('map', {
                zoomControl: false,
                attributionControl: false,
                zoomAnimation: false,
                fadeAnimation: false,
                markerZoomAnimation: false,
                background: 'transparent'
            }).setView([35.6895, 139.6917], ZOOM_LEVEL);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                opacity: 0.9,
                maxZoom: 19
            }).addTo(map);

            pathPolyline = L.polyline([], {
                color: 'red',
                weight: 5,
                opacity: 0.8,
                lineJoin: 'round'
            }).addTo(map);

            fetch(GEOJSON_PATH)
                .then(res => { if(!res.ok) throw new Error(); return res.json(); })
                .then(data => {
                    L.geoJSON(data, {
                        style: { color: "#00ff00", weight: 2, opacity: 0.6, fillOpacity: 0 }
                    }).addTo(map);
                })
                .catch(err => console.log('GeoJSON not found/loaded'));
        }

        // --- WebSocket ---
        function connectWebSocket() {
            updateStatus("Connecting to " + WS_URL + " ...");
            try {
                ws = new WebSocket(WS_URL);
            } catch (e) {
                scheduleReconnect();
                return;
            }

            ws.onopen = () => {
                console.log('WS Connected');
                updateStatus("Connected");
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.lat !== undefined && data.lon !== undefined) {
                        updatePosition(data.lat, data.lon, data.speed);
                    }
                } catch (e) {
                    console.error('JSON Parse Error', e);
                }
            };

            ws.onclose = () => {
                updateStatus("Disconnected. Retrying in 10s...");
                scheduleReconnect();
            };

            ws.onerror = () => {
                ws.close();
            };
        }

        function scheduleReconnect() {
            setTimeout(connectWebSocket, RECONNECT_INTERVAL);
        }

        function updatePosition(lat, lng, speedRaw) {
            const speedMs = parseFloat(speedRaw) || 0;
            const speedKmh = (speedMs * 3.6).toFixed(0); 
            const currentLatLng = L.latLng(lat, lng);

            if (!currentMarker) {
                currentMarker = L.marker(currentLatLng, {icon: pinIcon}).addTo(map);
            } else {
                currentMarker.setLatLng(currentLatLng);
            }

            map.panTo(currentLatLng, {animate: false});

            if (lastLatLng) {
                const dist = lastLatLng.distanceTo(currentLatLng);
                if (dist > 1) { 
                    totalDistance += dist;
                    pathCoords.push(currentLatLng);
                    pathPolyline.setLatLngs(pathCoords);
                    lastLatLng = currentLatLng;
                }
            } else {
                lastLatLng = currentLatLng;
                pathCoords.push(currentLatLng);
            }

            const distKm = (totalDistance / 1000).toFixed(1);
            document.getElementById('speed-dist').innerText = `${speedKmh}km/h (計 ${distKm}km)`;
            document.getElementById('coords').innerText = `${lat.toFixed(5)} / ${lng.toFixed(5)}`;
        }

        function updateStatus(msg) {
            const el = document.getElementById('status-indicator');
            if(el) el.innerText = msg;
        }

        // --- コンパス (修正済み) ---
        function startCompass() {
            if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', (event) => {
                    let heading = 0;
                    
                    // iOSとAndroid/その他で取得プロパティが違う
                    if (event.webkitCompassHeading) {
                        heading = event.webkitCompassHeading;
                    } else if (event.alpha) {
                        // Androidの場合、標準では北=0だが、機種依存が激しい
                        heading = 360 - event.alpha; 
                    }

                    // --- 画面の向き(回転)補正 ---
                    // 横持ち(Landscape)の場合、画面の角度(90度など)を足し合わせる必要があります
                    let screenAngle = 0;
                    if (window.screen && window.screen.orientation) {
                        screenAngle = window.screen.orientation.angle;
                    } else if (typeof window.orientation !== 'undefined') {
                        screenAngle = window.orientation;
                    }

                    // ヘディング(方位) + 画面回転 + 手動オフセット
                    let finalHeading = heading + screenAngle + HEADING_OFFSET;

                    rotateMap(finalHeading);
                }, true);
            }
        }

        function rotateMap(heading) {
            const mapDiv = document.getElementById('map');
            // マップ全体を回転（北を上にする基準から、進行方向を上にするためマイナス回転）
            mapDiv.style.transform = `translate(-50%, -50%) rotate(${-heading}deg)`;

            // ピンは画面に対して常に上を向くように、マップの回転を打ち消す（プラス回転）
            if (currentMarker) {
                const iconElement = currentMarker.getElement();
                if (iconElement) {
                    // 既存のtranslateなどは維持しないと位置がずれる可能性があるが、
                    // L.divIconは通常 margin-left/top で位置合わせするため transform は空または scale 等
                    // ここではシンプルに rotate を適用
                    // ※Leafletの内部的なtransformと競合しないよう、icon内部のSVGなどを回すのが安全だが
                    // 簡易的に要素自体を回す
                    const currentTransform = iconElement.style.transform.split(' rotate')[0];
                    iconElement.style.transform = `${currentTransform} rotate(${heading}deg)`;
                }
            }
        }

        window.onload = () => {
            initMap();
            connectWebSocket();
            startCompass();
        };

    </script>
</body>
</html>
